import axios from "axios";

// Gemini API configuration
const GEMINI_API_KEY = "AIzaSyCOLsr0_ADY0Lsgs1Vl9TZattNpLBwyGlQ";
const GEMINI_TEXT_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent";
const GEMINI_VISION_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent";

export interface GeminiResponse {
  text: string;
  success: boolean;
  error?: string;
}

export interface GeminiGenerationConfig {
  temperature?: number;
  topK?: number;
  topP?: number;
  maxOutputTokens?: number;
  stopSequences?: string[];
}

export interface GeminiSafetySettings {
  category: string;
  threshold: string;
}

export class GeminiService {
  private apiKey: string;

  constructor(apiKey?: string) {
    this.apiKey = apiKey || GEMINI_API_KEY;
    if (!this.apiKey) {
      throw new Error("Gemini API key not provided");
    }
  }

  async generateText(
    prompt: string,
    config: GeminiGenerationConfig = {}
  ): Promise<GeminiResponse> {
    try {
      const defaultConfig: GeminiGenerationConfig = {
        temperature: 0.8,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 2048,
        ...config
      };

      const response = await axios.post(
        `${GEMINI_TEXT_API_URL}?key=${this.apiKey}`,
        {
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: defaultConfig,
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        },
        {
          headers: {
            'Content-Type': 'application/json',
          },
          timeout: 30000 // 30 second timeout
        }
      );

      const text = response.data.candidates?.[0]?.content?.parts?.[0]?.text || "";
      
      if (!text) {
        return {
          text: "",
          success: false,
          error: "No text generated by Gemini"
        };
      }

      return {
        text,
        success: true
      };

    } catch (error: any) {
      console.error('Gemini API error:', error.response?.data || error.message);
      
      return {
        text: "",
        success: false,
        error: error.response?.data?.error?.message || error.message || "Unknown error"
      };
    }
  }

  async generateAdCopy(
    productData: any,
    targetAudience: any,
    objective: string
  ): Promise<GeminiResponse> {
    const prompt = `
    Generate high-converting Facebook ad copy for the following product and audience:

    Product Information:
    - Name: ${productData.title}
    - Price: $${productData.price}
    - Description: ${productData.description}
    - Category: ${productData.category || 'General'}

    Target Audience:
    - Age: ${targetAudience.age_min}-${targetAudience.age_max}
    - Interests: ${targetAudience.interests?.join(', ') || 'General interests'}
    - Location: ${targetAudience.countries?.join(', ') || 'United States'}

    Campaign Objective: ${objective}

    Generate the following in JSON format:
    {
      "headlines": [5 compelling headlines, max 40 characters each],
      "primaryTexts": [5 primary text variations, max 125 characters each],
      "descriptions": [3 descriptions, max 30 words each],
      "callToActions": [3 CTA options]
    }

    Focus on:
    - Emotional triggers and benefits
    - Social proof and urgency
    - Clear value propositions
    - Action-oriented language
    - Mobile-friendly formatting

    Return only valid JSON.
    `;

    return await this.generateText(prompt, {
      temperature: 0.9,
      maxOutputTokens: 1024
    });
  }

  async generateGrowthTips(
    businessProfile: any,
    performanceData: any,
    insights: any[]
  ): Promise<GeminiResponse> {
    const prompt = `
    Generate personalized growth tips for an e-commerce business:

    Business Profile:
    - Industry: ${businessProfile.industry}
    - Monthly Revenue: $${businessProfile.monthlyRevenue}
    - Ad Spend: $${businessProfile.adSpend}
    - Experience: ${businessProfile.experience}
    - Goals: ${businessProfile.goals?.join(', ')}

    Current Performance:
    - ROAS: ${performanceData.roas}
    - CTR: ${performanceData.ctr}%
    - Conversion Rate: ${performanceData.conversionRate}%

    Performance Insights:
    ${insights.map(i => `- ${i.metric}: ${i.value} (benchmark: ${i.benchmark})`).join('\n')}

    Generate 3 specific, actionable growth tips in JSON format:
    [
      {
        "title": "Tip title",
        "description": "Detailed description",
        "category": "advertising|conversion|retention|product",
        "impact": "high|medium|low",
        "effort": "high|medium|low",
        "expectedImprovement": {
          "metric": "ROAS|CTR|Revenue",
          "value": 25,
          "unit": "percentage"
        },
        "timeframe": "1-2 weeks",
        "difficulty": "beginner|intermediate|advanced",
        "actionSteps": [
          {
            "step": 1,
            "title": "Step title",
            "description": "Step description",
            "estimatedTime": "30 minutes"
          }
        ]
      }
    ]

    Return only valid JSON array.
    `;

    return await this.generateText(prompt, {
      temperature: 0.8,
      maxOutputTokens: 2048
    });
  }

  async generateFunnelStrategy(
    productData: any[],
    totalBudget: number,
    targetCountries: string[]
  ): Promise<GeminiResponse> {
    const prompt = `
    Create an optimal Facebook advertising funnel strategy:

    Products:
    ${productData.map(p => `- ${p.title}: $${p.price}`).join('\n')}

    Budget: $${totalBudget}
    Target Countries: ${targetCountries.join(', ')}

    Generate a 3-stage funnel strategy in JSON format:
    {
      "stages": [
        {
          "name": "Awareness Stage",
          "objective": "REACH",
          "budgetPercentage": 50,
          "audienceType": "cold",
          "targeting": {
            "interests": ["interest1", "interest2"],
            "behaviors": ["behavior1", "behavior2"],
            "demographics": {
              "age_min": 25,
              "age_max": 55,
              "genders": [1, 2]
            }
          },
          "creativeStrategy": {
            "adFormat": "single_image",
            "messaging": "awareness",
            "cta": "LEARN_MORE"
          }
        }
      ]
    }

    Focus on:
    - Logical funnel progression
    - Appropriate budget allocation
    - Relevant audience targeting
    - Optimal creative formats

    Return only valid JSON.
    `;

    return await this.generateText(prompt, {
      temperature: 0.7,
      maxOutputTokens: 1536
    });
  }

  async enhanceImageDescription(
    basePrompt: string,
    style: 'product' | 'lifestyle' | 'abstract' | 'testimonial'
  ): Promise<GeminiResponse> {
    const prompt = `
    Enhance this image description for professional advertising purposes:
    "${basePrompt}"

    Style: ${style}

    Create a detailed, professional image description that includes:
    - Specific visual elements and composition
    - Color palette and lighting
    - Emotional appeal and mood
    - Technical photography details
    - Brand-appropriate aesthetics

    The description should be suitable for:
    - High-converting Facebook/Instagram ads
    - Professional commercial photography
    - AI image generation prompts

    Focus on creating vivid, specific imagery that would result in compelling advertising visuals.
    Keep the description under 200 words but make it highly detailed and actionable.
    `;

    return await this.generateText(prompt, {
      temperature: 0.8,
      maxOutputTokens: 512
    });
  }

  async analyzeCompetitorStrategy(
    competitorData: any,
    productCategory: string
  ): Promise<GeminiResponse> {
    const prompt = `
    Analyze competitor advertising strategy and provide actionable insights:

    Competitor Information:
    - Name: ${competitorData.name}
    - Category: ${productCategory}
    - Estimated Ad Spend: $${competitorData.adSpend}
    - Market Position: ${competitorData.position}

    Provide analysis in JSON format:
    {
      "strengths": ["strength1", "strength2"],
      "weaknesses": ["weakness1", "weakness2"],
      "opportunities": ["opportunity1", "opportunity2"],
      "recommendations": [
        {
          "strategy": "Strategy name",
          "description": "Detailed description",
          "expectedImpact": "high|medium|low",
          "implementation": "How to implement"
        }
      ],
      "budgetRecommendations": [
        {
          "channel": "Facebook Ads",
          "allocation": 60,
          "reasoning": "Why this allocation"
        }
      ]
    }

    Focus on actionable insights that can be implemented immediately.
    Return only valid JSON.
    `;

    return await this.generateText(prompt, {
      temperature: 0.7,
      maxOutputTokens: 1024
    });
  }

  async generateOptimizationRecommendations(
    campaignData: any,
    performanceMetrics: any
  ): Promise<GeminiResponse> {
    const prompt = `
    Analyze campaign performance and generate optimization recommendations:

    Campaign Data:
    - Name: ${campaignData.name}
    - Budget: $${campaignData.budget}
    - Objective: ${campaignData.objective}
    - Duration: ${campaignData.duration} days

    Performance Metrics:
    - ROAS: ${performanceMetrics.roas}
    - CTR: ${performanceMetrics.ctr}%
    - CPC: $${performanceMetrics.cpc}
    - Conversion Rate: ${performanceMetrics.cvr}%
    - Spend: $${performanceMetrics.spend}

    Generate optimization recommendations in JSON format:
    {
      "recommendations": [
        {
          "type": "budget|creative|audience|bidding",
          "action": "increase|decrease|pause|test|optimize",
          "currentValue": "current state",
          "recommendedValue": "recommended change",
          "expectedImprovement": 0.25,
          "confidence": 0.8,
          "reasoning": "Why this change is recommended",
          "priority": "high|medium|low"
        }
      ],
      "riskAssessment": {
        "level": "low|medium|high",
        "factors": ["factor1", "factor2"],
        "mitigation": "How to reduce risk"
      },
      "nextSteps": [
        "Step 1: Action to take",
        "Step 2: Follow-up action"
      ]
    }

    Focus on data-driven recommendations with clear reasoning.
    Return only valid JSON.
    `;

    return await this.generateText(prompt, {
      temperature: 0.6,
      maxOutputTokens: 1024
    });
  }

  // Utility method to validate and parse JSON responses
  parseJSONResponse(response: GeminiResponse): { success: boolean; data?: any; error?: string } {
    if (!response.success) {
      return { success: false, error: response.error };
    }

    try {
      const data = JSON.parse(response.text);
      return { success: true, data };
    } catch (error) {
      return { 
        success: false, 
        error: `Failed to parse JSON: ${error instanceof Error ? error.message : 'Unknown error'}` 
      };
    }
  }

  // Method to test API connectivity
  async testConnection(): Promise<GeminiResponse> {
    return await this.generateText("Hello, this is a test. Please respond with 'Connection successful!'", {
      maxOutputTokens: 50
    });
  }
}

// Export a singleton instance
export const geminiService = new GeminiService();